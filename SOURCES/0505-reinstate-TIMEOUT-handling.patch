From 914f9e706e393e8a31230327204d438f68d58f9c Mon Sep 17 00:00:00 2001
From: Tom Gundersen <teg@jklm.no>
Date: Thu, 15 Mar 2012 02:12:43 +0100
Subject: [PATCH 505/509] reinstate TIMEOUT= handling

This reverts 43d5c5f03645c4b842659f9b5bd0ae465e885e92 and
57c6f8ae5f52a6e8ffc66a54966346f733dded39.

Signed-off-by: Tom Gundersen <teg@jklm.no>
---
 src/libudev/libudev-device.c  | 19 +++++++++++++++++++
 src/libudev/libudev-private.h |  1 +
 src/udev/udevd.c              | 13 ++++++++++---
 3 files changed, 30 insertions(+), 3 deletions(-)

diff --git a/src/libudev/libudev-device.c b/src/libudev/libudev-device.c
index 161181a..c4098ee 100644
--- a/src/libudev/libudev-device.c
+++ b/src/libudev/libudev-device.c
@@ -78,6 +78,7 @@ struct udev_device {
         struct udev_list tags_list;
         unsigned long long int seqnum;
         usec_t usec_initialized;
+        int timeout;
         int devlink_priority;
         int refcount;
         dev_t devnum;
@@ -172,6 +173,21 @@ static int udev_device_set_devnum(struct udev_device *udev_device, dev_t devnum)
         return 0;
 }
 
+int udev_device_get_timeout(struct udev_device *udev_device)
+{
+        return udev_device->timeout;
+}
+
+static int udev_device_set_timeout(struct udev_device *udev_device, int timeout)
+{
+        char num[32];
+
+        udev_device->timeout = timeout;
+        snprintf(num, sizeof(num), "%u", timeout);
+        udev_device_add_property(udev_device, "TIMEOUT", num);
+        return 0;
+}
+
 const char *udev_device_get_devpath_old(struct udev_device *udev_device)
 {
         return udev_device->devpath_old;
@@ -462,6 +478,8 @@ void udev_device_add_property_from_string_parse(struct udev_device *udev_device,
                 udev_device_set_devpath_old(udev_device, &property[12]);
         } else if (startswith(property, "SEQNUM=")) {
                 udev_device_set_seqnum(udev_device, strtoull(&property[7], NULL, 10));
+        } else if (startswith(property, "TIMEOUT=")) {
+                udev_device_set_timeout(udev_device, strtoull(&property[8], NULL, 10));
         } else if (startswith(property, "IFINDEX=")) {
                 udev_device_set_ifindex(udev_device, strtoull(&property[8], NULL, 10));
         } else if (startswith(property, "DEVMODE=")) {
@@ -653,6 +671,7 @@ struct udev_device *udev_device_new(struct udev *udev)
         udev_list_init(udev, &udev_device->sysattr_value_list, true);
         udev_list_init(udev, &udev_device->sysattr_list, false);
         udev_list_init(udev, &udev_device->tags_list, true);
+        udev_device->timeout = -1;
         udev_device->watch_handle = -1;
         /* copy global properties */
         udev_list_entry_foreach(list_entry, udev_get_properties_list_entry(udev))
diff --git a/src/libudev/libudev-private.h b/src/libudev/libudev-private.h
index 54c51ac..d2124ea 100644
--- a/src/libudev/libudev-private.h
+++ b/src/libudev/libudev-private.h
@@ -77,6 +77,7 @@ const char *udev_device_get_id_filename(struct udev_device *udev_device);
 void udev_device_set_is_initialized(struct udev_device *udev_device);
 int udev_device_add_tag(struct udev_device *udev_device, const char *tag);
 void udev_device_cleanup_tags_list(struct udev_device *udev_device);
+int udev_device_get_timeout(struct udev_device *udev_device);
 usec_t udev_device_get_usec_initialized(struct udev_device *udev_device);
 void udev_device_set_usec_initialized(struct udev_device *udev_device, usec_t usec_initialized);
 int udev_device_get_devlink_priority(struct udev_device *udev_device);
diff --git a/src/udev/udevd.c b/src/udev/udevd.c
index 7c6c5d6..2c1ec20 100644
--- a/src/udev/udevd.c
+++ b/src/udev/udevd.c
@@ -391,7 +391,7 @@ out:
         }
 }
 
-static void event_run(struct event *event)
+static void event_run(struct event *event, bool force)
 {
         struct udev_list_node *loop;
 
@@ -417,7 +417,7 @@ static void event_run(struct event *event)
                 return;
         }
 
-        if (children >= children_max) {
+        if (!force && children >= children_max) {
                 if (children_max > 1)
                         log_debug("maximum number (%i) of children reached\n", children);
                 return;
@@ -455,6 +455,13 @@ static int event_queue_insert(struct udev_device *dev)
 
         event->state = EVENT_QUEUED;
         udev_list_node_append(&event->node, &event_list);
+
+        /* run all events with a timeout set immediately */
+        if (udev_device_get_timeout(dev) > 0) {
+                event_run(event, true);
+                return 0;
+        }
+
         return 0;
 }
 
@@ -566,7 +573,7 @@ static void event_queue_start(struct udev *udev)
                 if (is_devpath_busy(event))
                         continue;
 
-                event_run(event);
+                event_run(event, false);
         }
 }
 
-- 
1.8.4.5

