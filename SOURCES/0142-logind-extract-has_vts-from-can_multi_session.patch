From bf7825ae69f53a7e80a740547919833e49ed1df4 Mon Sep 17 00:00:00 2001
From: David Herrmann <dh.herrmann@gmail.com>
Date: Tue, 17 Sep 2013 17:40:02 +0200
Subject: [PATCH 142/169] logind: extract has_vts() from can_multi_session()

We currently use seat_can_multi_session() to test for two things:
 * whether the seat can handle session-switching
 * whether the seat has VTs

As both are currently logically equivalent, we didn't care. However, we
want to allow session-switching on seats without VTs, so split this helper
into:
 * seat_can_multi_session(): whether session-switching is supported
 * seat_has_vts(): whether the seat has VTs

Note that only one seat on a system can have VTs. There is only one set of
them. We automatically assign them to seat0 as usual.

With this patch in place, we can easily add new session-switching/tracking
methods without breaking any VT code as it is now protected by has_vts(),
no longer by can_multi_session().
---
 src/login/logind-dbus.c    |  2 +-
 src/login/logind-seat.c    | 32 ++++++++++++++------------------
 src/login/logind-seat.h    |  1 +
 src/login/logind-session.c |  6 +++---
 4 files changed, 19 insertions(+), 22 deletions(-)

diff --git a/src/login/logind-dbus.c b/src/login/logind-dbus.c
index 4a23c93..fd8ee1b 100644
--- a/src/login/logind-dbus.c
+++ b/src/login/logind-dbus.c
@@ -429,7 +429,7 @@ static int bus_manager_create_session(Manager *m, DBusMessage *message) {
         }
 
         if (seat) {
-                if (seat_can_multi_session(seat)) {
+                if (seat_has_vts(seat)) {
                         if (vtnr > 63)
                                 return -EINVAL;
                 } else {
diff --git a/src/login/logind-seat.c b/src/login/logind-seat.c
index c5350fb..3dc529b 100644
--- a/src/login/logind-seat.c
+++ b/src/login/logind-seat.c
@@ -201,7 +201,7 @@ int seat_preallocate_vts(Seat *s) {
         if (s->manager->n_autovts <= 0)
                 return 0;
 
-        if (!seat_can_multi_session(s))
+        if (!seat_has_vts(s))
                 return 0;
 
         for (i = 1; i <= s->manager->n_autovts; i++) {
@@ -277,7 +277,7 @@ int seat_active_vt_changed(Seat *s, int vtnr) {
         assert(s);
         assert(vtnr >= 1);
 
-        if (!seat_can_multi_session(s))
+        if (!seat_has_vts(s))
                 return -EINVAL;
 
         log_debug("VT changed to %i", vtnr);
@@ -301,7 +301,7 @@ int seat_read_active_vt(Seat *s) {
 
         assert(s);
 
-        if (!seat_can_multi_session(s))
+        if (!seat_has_vts(s))
                 return 0;
 
         lseek(s->manager->console_active_fd, SEEK_SET, 0);
@@ -412,18 +412,20 @@ int seat_attach_session(Seat *s, Session *session) {
 
         seat_send_changed(s, "Sessions\0");
 
-        /* Note that even if a seat is not multi-session capable it
-         * still might have multiple sessions on it since old, dead
-         * sessions might continue to be tracked until all their
-         * processes are gone. The most recently added session
-         * (i.e. the first in s->sessions) is the one that matters. */
-
-        if (!seat_can_multi_session(s))
+        /* On seats with VTs, the VT logic defines which session is active. On
+         * seats without VTs, we automatically activate the first session. */
+        if (!seat_has_vts(s) && !s->active)
                 seat_set_active(s, session);
 
         return 0;
 }
 
+bool seat_has_vts(Seat *s) {
+        assert(s);
+
+        return seat_is_seat0(s) && s->manager->console_active_fd >= 0;
+}
+
 bool seat_is_seat0(Seat *s) {
         assert(s);
 
@@ -433,19 +435,13 @@ bool seat_is_seat0(Seat *s) {
 bool seat_can_multi_session(Seat *s) {
         assert(s);
 
-        if (!seat_is_seat0(s))
-                return false;
-
-        /* If we can't watch which VT is in the foreground, we don't
-         * support VT switching */
-
-        return s->manager->console_active_fd >= 0;
+        return seat_has_vts(s);
 }
 
 bool seat_can_tty(Seat *s) {
         assert(s);
 
-        return seat_is_seat0(s) && s->manager->console_active_fd >= 0;
+        return seat_has_vts(s);
 }
 
 bool seat_has_master_device(Seat *s) {
diff --git a/src/login/logind-seat.h b/src/login/logind-seat.h
index 47fe89a..d3438b8 100644
--- a/src/login/logind-seat.h
+++ b/src/login/logind-seat.h
@@ -60,6 +60,7 @@ int seat_preallocate_vts(Seat *s);
 
 int seat_attach_session(Seat *s, Session *session);
 
+bool seat_has_vts(Seat *s);
 bool seat_is_seat0(Seat *s);
 bool seat_can_multi_session(Seat *s);
 bool seat_can_tty(Seat *s);
diff --git a/src/login/logind-session.c b/src/login/logind-session.c
index ab1c79c..f856127 100644
--- a/src/login/logind-session.c
+++ b/src/login/logind-session.c
@@ -191,7 +191,7 @@ int session_save(Session *s) {
         if (s->service)
                 fprintf(f, "SERVICE=%s\n", s->service);
 
-        if (s->seat && seat_can_multi_session(s->seat))
+        if (s->seat && seat_has_vts(s->seat))
                 fprintf(f, "VTNR=%i\n", s->vtnr);
 
         if (s->leader > 0)
@@ -301,7 +301,7 @@ int session_load(Session *s) {
                         seat_attach_session(o, s);
         }
 
-        if (vtnr && s->seat && seat_can_multi_session(s->seat)) {
+        if (vtnr && s->seat && seat_has_vts(s->seat)) {
                 int v;
 
                 k = safe_atoi(vtnr, &v);
@@ -372,7 +372,7 @@ int session_activate(Session *s) {
         if (s->seat->active == s)
                 return 0;
 
-        assert(seat_is_seat0(s->seat));
+        assert(seat_has_vts(s->seat));
 
         return chvt(s->vtnr);
 }
-- 
1.8.4

