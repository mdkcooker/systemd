From faa65d2467c8f4c1409cc45beeb33736f393d69f Mon Sep 17 00:00:00 2001
From: Michael Olbrich <m.olbrich@pengutronix.de>
Date: Sun, 19 May 2013 12:10:55 +0200
Subject: [PATCH 116/160] service: kill processes with SIGKILL on watchdog
 failure

Just calling service_enter_dead() does not kill any processes.
As a result, the old process may still be running when the new one is
started.

After a watchdog failure the service is in an undefined state.
Using the normal shutdown mechanism makes no sense. Instead all processes
are just killed and the service can try to restart.

(cherry picked from commit 9e9c3abcfa6b93500960531d0d7aa64b8b2b0349)
---
 src/core/service.c | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/src/core/service.c b/src/core/service.c
index 3617c24..e110a41 100644
--- a/src/core/service.c
+++ b/src/core/service.c
@@ -235,7 +235,7 @@ static void service_stop_watchdog(Service *s) {
         s->watchdog_timestamp.monotonic = 0;
 }
 
-static void service_enter_dead(Service *s, ServiceResult f, bool allow_restart);
+static void service_enter_signal(Service *s, ServiceState state, ServiceResult f);
 
 static void service_handle_watchdog(Service *s) {
         usec_t offset;
@@ -249,7 +249,7 @@ static void service_handle_watchdog(Service *s) {
         offset = now(CLOCK_MONOTONIC) - s->watchdog_timestamp.monotonic;
         if (offset >= s->watchdog_usec) {
                 log_error_unit(UNIT(s)->id, "%s watchdog timeout!", UNIT(s)->id);
-                service_enter_dead(s, SERVICE_FAILURE_WATCHDOG, true);
+                service_enter_signal(s, SERVICE_FINAL_SIGKILL, SERVICE_FAILURE_WATCHDOG);
                 return;
         }
 
@@ -1939,8 +1939,6 @@ fail:
         service_enter_dead(s, SERVICE_FAILURE_RESOURCES, false);
 }
 
-static void service_enter_signal(Service *s, ServiceState state, ServiceResult f);
-
 static void service_enter_stop_post(Service *s, ServiceResult f) {
         int r;
         assert(s);
-- 
1.8.3.1

