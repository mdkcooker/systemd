From c1e6dc0e295821700ee2a0d3b52060e3a6b9a927 Mon Sep 17 00:00:00 2001
From: Tom Gundersen <teg@jklm.no>
Date: Thu, 15 Mar 2012 02:12:43 +0100
Subject: [PATCH 506/508] reinstate TIMEOUT= handling

This reverts 43d5c5f03645c4b842659f9b5bd0ae465e885e92 and
57c6f8ae5f52a6e8ffc66a54966346f733dded39.

Signed-off-by: Tom Gundersen <teg@jklm.no>
---
 src/libudev/libudev-device.c  | 19 +++++++++++++++++++
 src/libudev/libudev-private.h |  1 +
 src/udev/udevd.c              | 13 ++++++++++---
 3 files changed, 30 insertions(+), 3 deletions(-)

diff --git a/src/libudev/libudev-device.c b/src/libudev/libudev-device.c
index 6d2762d..daf77c7 100644
--- a/src/libudev/libudev-device.c
+++ b/src/libudev/libudev-device.c
@@ -68,6 +68,7 @@ struct udev_device {
         struct udev_list tags_list;
         unsigned long long int seqnum;
         usec_t usec_initialized;
+        int timeout;
         int devlink_priority;
         int refcount;
         dev_t devnum;
@@ -162,6 +163,21 @@ static int udev_device_set_devnum(struct udev_device *udev_device, dev_t devnum)
         return 0;
 }
 
+int udev_device_get_timeout(struct udev_device *udev_device)
+{
+        return udev_device->timeout;
+}
+
+static int udev_device_set_timeout(struct udev_device *udev_device, int timeout)
+{
+        char num[32];
+
+        udev_device->timeout = timeout;
+        snprintf(num, sizeof(num), "%u", timeout);
+        udev_device_add_property(udev_device, "TIMEOUT", num);
+        return 0;
+}
+
 const char *udev_device_get_devpath_old(struct udev_device *udev_device)
 {
         return udev_device->devpath_old;
@@ -418,6 +434,8 @@ void udev_device_add_property_from_string_parse(struct udev_device *udev_device,
                 udev_device_set_devpath_old(udev_device, &property[12]);
         } else if (startswith(property, "SEQNUM=")) {
                 udev_device_set_seqnum(udev_device, strtoull(&property[7], NULL, 10));
+        } else if (startswith(property, "TIMEOUT=")) {
+                udev_device_set_timeout(udev_device, strtoull(&property[8], NULL, 10));
         } else if (startswith(property, "IFINDEX=")) {
                 udev_device_set_ifindex(udev_device, strtoull(&property[8], NULL, 10));
         } else if (startswith(property, "DEVMODE=")) {
@@ -605,6 +623,7 @@ struct udev_device *udev_device_new(struct udev *udev)
         udev_list_init(udev, &udev_device->sysattr_value_list, true);
         udev_list_init(udev, &udev_device->sysattr_list, false);
         udev_list_init(udev, &udev_device->tags_list, true);
+        udev_device->timeout = -1;
         udev_device->watch_handle = -1;
         /* copy global properties */
         udev_list_entry_foreach(list_entry, udev_get_properties_list_entry(udev))
diff --git a/src/libudev/libudev-private.h b/src/libudev/libudev-private.h
index 2e6069b..1c6a875 100644
--- a/src/libudev/libudev-private.h
+++ b/src/libudev/libudev-private.h
@@ -66,6 +66,7 @@ const char *udev_device_get_id_filename(struct udev_device *udev_device);
 void udev_device_set_is_initialized(struct udev_device *udev_device);
 int udev_device_add_tag(struct udev_device *udev_device, const char *tag);
 void udev_device_cleanup_tags_list(struct udev_device *udev_device);
+int udev_device_get_timeout(struct udev_device *udev_device);
 usec_t udev_device_get_usec_initialized(struct udev_device *udev_device);
 void udev_device_set_usec_initialized(struct udev_device *udev_device, usec_t usec_initialized);
 int udev_device_get_devlink_priority(struct udev_device *udev_device);
diff --git a/src/udev/udevd.c b/src/udev/udevd.c
index b69f3f8..58e98d0 100644
--- a/src/udev/udevd.c
+++ b/src/udev/udevd.c
@@ -388,7 +388,7 @@ out:
         }
 }
 
-static void event_run(struct event *event)
+static void event_run(struct event *event, bool force)
 {
         struct udev_list_node *loop;
 
@@ -414,7 +414,7 @@ static void event_run(struct event *event)
                 return;
         }
 
-        if (children >= children_max) {
+        if (!force && children >= children_max) {
                 if (children_max > 1)
                         log_debug("maximum number (%i) of children reached\n", children);
                 return;
@@ -450,6 +450,13 @@ static int event_queue_insert(struct udev_device *dev)
 
         event->state = EVENT_QUEUED;
         udev_list_node_append(&event->node, &event_list);
+
+        /* run all events with a timeout set immediately */
+        if (udev_device_get_timeout(dev) > 0) {
+                event_run(event, true);
+                return 0;
+        }
+
         return 0;
 }
 
@@ -559,7 +566,7 @@ static void event_queue_start(struct udev *udev)
                 if (is_devpath_busy(event))
                         continue;
 
-                event_run(event);
+                event_run(event, false);
         }
 }
 
-- 
1.8.1.5

