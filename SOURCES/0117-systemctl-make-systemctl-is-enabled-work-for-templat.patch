From 56c1edd8df24e9fec5090c6d4cc720a94822749d Mon Sep 17 00:00:00 2001
From: Michael Tremer <michael.tremer@ipfire.org>
Date: Sun, 19 May 2013 15:45:48 +0200
Subject: [PATCH 117/160] systemctl: make systemctl is-enabled work for
 templated units

Patch resolves the problem that 'systemctl is-enabled' does
not work for templated units.

Without this patch, systemctl is-enabled something@abc.service
returned "No such file or directory", because it first checked
if /usr/lib/systemd/system/something@abc.service, etc. exists.
If systemctl is-enabled is called for templated units, this
check should be omitted and it should search for symlinks in
the .wants dirs right away.

This patch fixes the broken behaviour and resolves
  https://bugs.freedesktop.org/show_bug.cgi?id=55318.

[zj: fixed the patch to still check for broken symlinks and
     masked instances. Also removed untrue assumptions from
     the patch description.]

(cherry picked from commit 67820a0cbdc9d72a1074debf8b2bc72203c775cc)
---
 src/shared/install.c | 33 +++++++++++++++++++--------------
 1 file changed, 19 insertions(+), 14 deletions(-)

diff --git a/src/shared/install.c b/src/shared/install.c
index edf4d2a..8f27c6d 100644
--- a/src/shared/install.c
+++ b/src/shared/install.c
@@ -1609,24 +1609,29 @@ UnitFileState unit_file_get_state(
                 if (!path)
                         return -ENOMEM;
 
+                /*
+                 * Search for a unit file in our default paths, to
+                 * be sure, that there are no broken symlinks.
+                 */
                 if (lstat(path, &st) < 0) {
                         r = -errno;
-                        if (errno == ENOENT)
-                                continue;
-
-                        return -errno;
-                }
+                        if (errno != ENOENT)
+                                return r;
 
-                if (!S_ISREG(st.st_mode) && !S_ISLNK(st.st_mode))
-                        return -ENOENT;
+                        if (!unit_name_is_instance(name))
+                                continue;
+                } else {
+                        if (!S_ISREG(st.st_mode) && !S_ISLNK(st.st_mode))
+                                return -ENOENT;
 
-                r = null_or_empty_path(path);
-                if (r < 0 && r != -ENOENT)
-                        return r;
-                else if (r > 0) {
-                        state = path_startswith(*i, "/run") ?
-                                UNIT_FILE_MASKED_RUNTIME : UNIT_FILE_MASKED;
-                        return state;
+                        r = null_or_empty_path(path);
+                        if (r < 0 && r != -ENOENT)
+                                return r;
+                        else if (r > 0) {
+                                state = path_startswith(*i, "/run") ?
+                                        UNIT_FILE_MASKED_RUNTIME : UNIT_FILE_MASKED;
+                                return state;
+                        }
                 }
 
                 r = find_symlinks_in_scope(scope, root_dir, name, &state);
-- 
1.8.3.1

