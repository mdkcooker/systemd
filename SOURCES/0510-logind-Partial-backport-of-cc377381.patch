From 4481a13ee015c3cd470f9acefd067e882bfcd6ad Mon Sep 17 00:00:00 2001
From: Colin Guthrie <colin@mageia.org>
Date: Wed, 18 Dec 2013 14:35:35 +0000
Subject: [PATCH 510/514] logind: Partial backport of cc377381

This backports the part that ensures the slice and service jobs are active
before doing gc. This should allow gc to run more often
---
 src/login/logind-dbus.c | 51 +++++++++++++++++++++++++++++++++++++++++++++++++
 src/login/logind-user.c |  5 ++++-
 src/login/logind.h      |  1 +
 3 files changed, 56 insertions(+), 1 deletion(-)

diff --git a/src/login/logind-dbus.c b/src/login/logind-dbus.c
index a5ab19c..2c99629 100644
--- a/src/login/logind-dbus.c
+++ b/src/login/logind-dbus.c
@@ -2914,3 +2914,54 @@ int manager_unit_is_active(Manager *manager, const char *unit) {
 
         return !streq(state, "inactive") && !streq(state, "failed");
 }
+
+int manager_job_is_active(Manager *manager, const char *path) {
+
+        const char *interface = "org.freedesktop.systemd1.Job";
+        const char *property = "State";
+        _cleanup_dbus_message_unref_ DBusMessage *reply = NULL;
+        DBusError error;
+        int r;
+
+        assert(manager);
+        assert(path);
+
+        dbus_error_init(&error);
+
+        r = bus_method_call_with_reply(
+                        manager->bus,
+                        "org.freedesktop.systemd1",
+                        path,
+                        "org.freedesktop.DBus.Properties",
+                        "Get",
+                        &reply,
+                        &error,
+                        DBUS_TYPE_STRING, &interface,
+                        DBUS_TYPE_STRING, &property,
+                        DBUS_TYPE_INVALID);
+        if (r < 0) {
+                if (dbus_error_has_name(&error, DBUS_ERROR_NO_REPLY) ||
+                    dbus_error_has_name(&error, DBUS_ERROR_DISCONNECTED)) {
+                        /* systemd might have droppped off
+                         * momentarily, let's not make this an
+                         * error */
+
+                        dbus_error_free(&error);
+                        return true;
+                }
+
+                if (dbus_error_has_name(&error, DBUS_ERROR_UNKNOWN_OBJECT)) {
+                        dbus_error_free(&error);
+                        return false;
+                }
+
+                log_error("Failed to query State: %s", bus_error(&error, r));
+                dbus_error_free(&error);
+                return r;
+        }
+
+        /* We don't actually care about the state really. The fact
+         * that we could read the job state is enough for us */
+
+        return true;
+}
diff --git a/src/login/logind-user.c b/src/login/logind-user.c
index 3aeac13..92fe778 100644
--- a/src/login/logind-user.c
+++ b/src/login/logind-user.c
@@ -628,7 +628,10 @@ int user_check_gc(User *u, bool drop_not_started) {
         if (user_check_linger_file(u) > 0)
                 return 1;
 
-        if (u->slice_job || u->service_job)
+        if (u->slice_job && manager_job_is_active(u->manager, u->slice_job))
+                return 1;
+
+        if (u->service_job && manager_job_is_active(u->manager, u->service_job))
                 return 1;
 
         if (u->slice && manager_unit_is_active(u->manager, u->slice) != 0)
diff --git a/src/login/logind.h b/src/login/logind.h
index 540572f..b21c382 100644
--- a/src/login/logind.h
+++ b/src/login/logind.h
@@ -190,6 +190,7 @@ int manager_stop_unit(Manager *manager, const char *unit, DBusError *error, char
 int manager_abandon_scope(Manager *manager, const char *scope, DBusError *error);
 int manager_kill_unit(Manager *manager, const char *unit, KillWho who, int signo, DBusError *error);
 int manager_unit_is_active(Manager *manager, const char *unit);
+int manager_job_is_active(Manager *manager, const char *path);
 
 /* gperf lookup function */
 const struct ConfigPerfItem* logind_gperf_lookup(const char *key, unsigned length);
-- 
1.8.4.5

